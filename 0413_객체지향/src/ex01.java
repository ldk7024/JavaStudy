import java.util.Random;

public class ex01 {

	public static void main(String[] args) {
	// class -> 설계도, 설계도면
	// object -> 객체 (db에서의 entity) -> created from the class
	// 클래스의 구조
	// -> attribute(속성): 변수 (필드)   -> ex) 이름, 키, 나이, 성별, 머리색, 눈동자색
    // -> behavior (행동): 메서드(기능) -> ex) 걷다, 먹다, 자다, 말하다, 싸우다, 생각하다.
	// 객체지향프로그래밍의 특징 -> 캡상추다 -> 캡슐화, 상속, 추상화, 다형성
	// 추상화: 객체에서 공통된 속성과 행위를 추출하는 기법, 코드 상에서 구현(로직)부분을 제외한 오직 선언부분만을 설계, 상세한 정보는 무시하고 필요한 정보들만 간추려서 구성
	// 캡슐화: 관련된 필드와 메소드를 하나로 묶고, 실제 구현내용을 외부로부터 감추는 기법(정보은닉), 만일의 상황(타인이 외부에서 조작)을 대배해서 특정 속성이나 메소드를 사용자가 조작할 수 없도록 숨겨 놓은 것, 외부에서는 공개된 메소드(기능)의 인터페이스를 통해 접근할 수 있다.
	// 상속: 이미 작성된 클래스 (상위 클래스)의 특성을 그대로 이어받아 새로운 클래스(하위 클래스)를 생성하는 기법
    // -> 기존 코드를 그대로 재사용하거나 재정의 -> 재사용 + 확장	 -> 똑같은 상위클래스에 있는 코드를 굳이 하위클래스에 또 쓸 필요는 없음!
	// 오버라이딩 -> 기존 상위클래스에 있었던 특성을 확장하기위해 재정의 (다시한번써주는것)해주는 것
	// 다형성 -> 사전적 의미 , 다양한 형태로 나타날 수 있는 능력, 같은 기능 (메소드)를 호출하더라도 객체에 따라 다르게 동작하는 것, 상위클래스의 동작을 하위클래스에서 다시 정의하여 사용하는 것 또한 다형성으로 볼 수 있다.
	// 객체지향프로그래밍의 장점: 신뢰성 있는 소프트웨어를 쉽게 작성할 수 있다, 코드를 재사용하기 쉽다, 유지보수가 용이하다, 직관적인 코드 분석이 가능하다, 소프트웨어 생산성이 향상된다.
	// (메서드)오버로딩: 메서드 이름은 같고 매개변수 타입, 개수를 다르게 하는 것  ex) plus(1,2), plus(1,2,3), plus(1,2.0)
	// (매서드)오버라이딩: 상속(상위개념의 기능을 하위개념에서 재정의) -> 메서드 이름 같음, 타입같음, 개수 같음-> 로직이 달라짐
	// class의 구조
    // public class 클래스명 {
	//      자료형 필드명1;	
	//	        자료형 필드명2;         -> 객체의 속성 정의
	//	     ...
	//	   
	//      반환형 메소드1(){...}
	//      반환형 메소드2(){...}	-> 객체의 기능(행위)정의
	//	}	
	//    객체의 생성 
	//     클래스 객체명 = new 클래스();	
	
	// mvc 패턴 -> model view controller
	// 생성자의 특징 : 생성자는 메소드이다, 생성자의 이름은 클래스 이름과 동일해야한다, 생성자는 리턴타입을 지정할 수 없다, 생성자는 new 키워드를 통해 객체를 생성할 때만 호출된다, 생성자는 하나 이상 선언되어야함.
	// 개발자가 생성자를 정의하지 않으면 자동으로 기본 생성자가 정의됨 -> 기본 생성자를 디폴트 생성자라고 함, 컴파일러에 의해 자동생성
	// 모델 클래스 > 데이터를 나누는 클래스
	//	뷰클래스 > 눈에 보이는 거. 버튼, 레이아웃 등
	//	컨트롤러클래스 > 기능을 가지고 있는 클래스
	// 학생시스템으로 예를 들면 학생성적이나 목록같은거 -> 모델 클래스, 나중에 우리가 gui로 버튼 달고 레이아웃 수정하고 해서 눈에 보이게 하는 것들 -> 뷰 클래스, 우리가 학점을 계산하거나 출석을 계산할 때 들어가는 로직 같은 것 -> 컨트롤러 클래스
	
	
	
	
	
	
	
	
	
	
	
	
	
	}

}
